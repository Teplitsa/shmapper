(function (global){
var ym = { modules: global.ymaps.modules };

(function (modules){
var project = { DEBUG: false };
if (typeof modules == 'undefined' && typeof require == 'function') {
    var modules = require('ym');
}

modules.define('util.providePackage', ['system.mergeImports'], function (provide, mergeImports) {
    provide(function (srcPackage, packageArgs) {
        var packageProvide = packageArgs[0],
            packageModules = Array.prototype.slice.call(packageArgs, 1),
            ns = mergeImports.joinImports(srcPackage.name, {}, srcPackage.deps, packageModules);

        packageProvide(ns);
    });
});
})(ym.modules);

ym.modules.define('RS.MaskOverlay', [
  'util.defineClass',
  'overlay.Polygon',
  'geometry.pixel.Polygon'
], function (provide, defineClass, OverlayPolygon, GeometryPixelPolygon) {

/**
 * Класс оверлея маски.
 * @class
 * @name MaskOverlay
 * @param {ymaps.geometry.pixel.Polygon} geometry Пиксельная геометкрия полигона.
 * @param {Object} data Данные.
 * @param {Object} options Опции.
 */
var MaskOverlay = defineClass(function (geometry, data, options) {
    MaskOverlay.superclass.constructor.call(this, geometry, data, options);
}, OverlayPolygon, /** @lends MaskOverlay.prototype */{
    /**
     * Перекрываем публичный метод.
     * @function
     * @name MaskOverlay.setGeometry
     * @param {ymaps.geometry.pixel.Polygon} geometry Пиксельная геометрия полигона.
     */
    setGeometry: function (geometry) {
        MaskOverlay.superclass.setGeometry.call(
            this,
            this.getMap() ? this._createGeometry(geometry) : geometry
        );
    },
    /**
     * Создание пиксельной геометрии.
     * @function
     * @private
     * @name MaskOverlay._createGeometry
     * @returns {ymaps.geometry.pixel.Polygon} Пиксельная геометрия полигона.
     */
    _createGeometry: function (geometry) {
        var lineCoordinates = geometry.getCoordinates().slice(0),
            map = this.getMap(),
            center = map.getGlobalPixelCenter(),
            size = map.container.getSize(),
            d = 512;

        lineCoordinates.push([
            [center[0] - size[0] - d, center[1] - size[1] - d],
            [center[0] + size[0] + d, center[1] - size[1] - d],
            [center[0] + size[0] + d, center[1] + size[1] + d],
            [center[0] - size[0] - d, center[1] + size[1] + d],
            [center[0] - size[0] - d, center[1] - size[1] - d]
        ]);

        return new GeometryPixelPolygon(lineCoordinates, 'evenOdd');
    }
});

provide(MaskOverlay);

});

ym.modules.define('RS.MapMaskView', [
  'util.defineClass',
  'geometry.Polygon',
  'RS.MaskOverlay'
], function (provide, defineClass, GeometryPolygon, MaskOverlay) {

/**
 * Класс-отображение данных на карте ввиде маски.
 * @class
 * @name RegionSelector.MapMaskView
 * @param {ymaps.Map} map Карта.
 */
var MapMaskView = defineClass(function (map) {
    this._map = map;
    this._overlay = null;
    this._geometry = null;
}, /** @lends RegionSelector.MapMaskView.prototype */{
    /**
     * Отображение данных на карте.
     * @function
     * @name RegionSelector.MapMaskView.render
     * @param {ymaps.data.Manager} data Менеджер данных.
     * @returns {RegionSelector.MapMaskView} Возвращает ссылку на себя.
     */
    render: function (data) {
        var coordinates = [];

        data.get('regions')
            .each(function (geoObject) {
                coordinates.push.apply(coordinates, geoObject.geometry.getCoordinates());
            });

        this._createGeometry(coordinates);
        this._createOverlay(this._geometry.getPixelGeometry());
        this._attachHandlers();

        return this;
    },
    /**
     * Удаление данных с карты.
     * @function
     * @name RegionSelector.MapMaskView.clear
     * @returns {RegionSelector.MapMaskView} Возвращает ссылку на себя.
     */
    clear: function () {
        if(this._geometry) {
            this._detachHandlers();
            this._geometry.setMap(null);
            this._overlay.setMap(null);
        }
        this._geometry = this._overlay = null;

        return this;
    },
    /**
     * Добавление обработчиков событий.
     * @function
     * @private
     * @name RegionSelector.MapMaskView._attachHandlers
     */
    _attachHandlers: function () {
        this._geometry.events
            .add('pixelgeometrychange', this._onPixelGeometryChange, this);
        this._map.events
            .add('boundschange', this._onBoundsChange, this);
    },
    /**
     * Удаление обработчиков событий.
     * @function
     * @private
     * @name RegionSelector.MapMaskView._detachHandlers
     */
    _detachHandlers: function () {
        this._map.events
            .remove('boundschange', this._onBoundsChange, this);
        this._geometry.events
            .remove('pixelgeometrychange', this._onPixelGeometryChange, this);
    },
    /**
     * Обработчик события изменения пискельной геометрии.
     * @function
     * @private
     * @name RegionSelector.MapMaskView._onPixelGeometryChange
     * @param {ymaps.data.Manager} e Менеджер данных.
     */
    _onPixelGeometryChange: function (e) {
        this._createOverlay(e.get('pixelGeometry'));
    },
    /**
     * Обработчик события смены центра/масштаба карты.
     * @function
     * @private
     * @name RegionSelector.MapMaskView._onBoundsChange
     */
    _onBoundsChange: function (e) {
        if(e.get('oldZoom') !== e.get('newZoom')) {
            this._createOverlay(this._geometry.getPixelGeometry());
        }
    },
    /**
     * Создание геометрии типа "Polygon".
     * @function
     * @private
     * @name RegionSelector.MapMaskView._createGeometry
     * @param {Number[][]} coordinates Координаты вершин ломаных, определяющих внешнюю и внутренние границы многоугольника.
     */
    _createGeometry: function (coordinates) {
        this._geometry = new GeometryPolygon(coordinates, 'evenOdd',{
            projection: this._map.options.get('projection')
        });
        this._geometry.setMap(this._map);
    },
    /**
     * Создание оверлея.
     * @function
     * @private
     * @name RegionSelector.MapMaskView._createOverlay
     * @param {ymaps.geometry.pixel.Polygon} geometry Пиксельная геометрия полигона.
     */
    _createOverlay: function (geometry) {
        if(!this._overlay) {
            this._overlay = new MaskOverlay(geometry, null, this.getDefaults());
        }
        this._overlay.setMap(this._map);
        this._overlay.setGeometry(geometry);
    },
    /**
     * Опции по-умолчанию.
     * @function
     * @name RegionSelector.MapMaskView.getDefaults
     * @returns {Object} Опции.
     */
    getDefaults: function () {
        return {
            zIndex: 1,
            stroke: false,
            strokeColor: false,
            fillColor: 'CCC',
            interactivityModel: 'default#transparent',
            cursor: 'grab'
        };
    }
});

provide(MapMaskView);

});

ym.modules.define('RS.Model', [
  'util.defineClass',
  'util.bind',
  'Monitor',
  'option.Manager',
  'event.Manager',
  'regions'
], function (provide, defineClass, bind, Monitor, OptionManager, EventManager, Regions) {

/**
 * Класс-модель
 * @class
 * @name RegionSelector.Model
 */
var Model = defineClass(function () {
    this.events = new EventManager();
    this.options = new OptionManager({
        preset: this.getDefaults()
    });
}, /** @lends RegionSelector.Model.prototype */{
    /**
     * Загружаем данные.
     * @function
     * @name RegionSelector.Model.load
     */
    load: function () {
        Regions.load(
            this.options.get('country'), {
                lang: this.options.get('lang'),
                quality: this.options.get('quality')
            }
        ).then(
            bind(this._onDataLoaded, this)
        );
    },
    /**
     * Обработчик загрузки данных.
     * @function
     * @private
     * @name RegionSelector.Model._onDataLoaded
     * @param {Object} data Данные региона.
     */
    _onDataLoaded: function (data) {
        this.events.fire('load', {
            regions: data.geoObjects,
            target: this
        });
    },
    /**
     * Опции модели по-умолчанию.
     * @function
     * @name RegionSelector.Model.getDefaults
     * @returns {Object} Опции модели.
     */
    getDefaults: function () {
        return {
            country: 'RU',
            lang: 'ru',
            quality: 0
        };
    }
});

provide(Model);

});

ym.modules.define('RS.RegionSelector', [
  'util.defineClass',
  'RS.Model',
  'RS.MapMaskView',
], function (provide, defineClass, Model, MapMaskView) {

/**
 * Класс-контрол выбора региона
 * @class
 * @name RegionSelector
 * @param {ymaps.Map} map Карта.
 * @param {jQuery} listContainer Контейнер списка областей.
 * @param {jQuery} optContainer Контейнер для настроек.
 * @param {jQuery} titleContainer Контейнер заголовка.
 */
var RegionSelector = defineClass(function (map, listContainer, optContainer, titleContainer) {
    this._model = new Model();
    this._views = [
        this._mapMaskView = new MapMaskView(map)
    ];

    this._attachHandlers();
    this._model.load();
}, /** @lends RegionSelector.prototype */{
    /**
     * Добавление обработчиков событий.
     * @function
     * @private
     * @name RegionSelector._attachHandlers
     */
    _attachHandlers: function () {
        this._model.events.add('load', this._onRegionsLoaded, this);
    },

    /**
     * Обработчик события загрузки данных о регионах.
     * @function
     * @private
     * @name RegionSelector._onRegionsLoaded
     * @param {ymaps.data.Manager} data Менеджер данных.
     */
    _onRegionsLoaded: function (data) {
        for(var i = 0, len = this._views.length; i < len; i++) {
            this._views[i]
                .clear()
                .render(data);
        }
    }
});

provide(RegionSelector);

});

})(this);